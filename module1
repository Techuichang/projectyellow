import websocket
import json
import zlib
import time
import datetime, os
from apscheduler.schedulers.background import BackgroundScheduler

try:
    import thread
except ImportError:
    import _thread as thread

import re
import pymongo
import pandas as pd
from queue import Queue
import threading
import schedule
import logging

# 函数运行后 t1定时开始不间断取值  t2进行获取结果保存为df格式 定时输出



websocket_url = 'wss://tx-bj4-live-comet-03.chat.bilibili.com/sub'  # wss://tx-bj4-live-comet-04.chat.bilibili.com/sub,wss://tx-gz3-live-comet-03.chat.bilibili.com/sub,wss://hw-bj-live-comet-02.chat.bilibili.com/sub

#send1=[0x00, 0x00, 0x00, 0xEA, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x01, 0x7B, 0x22, 0x75, 0x69, 0x64, 0x22, 0x3A, 0x39, 0x38, 0x38, 0x36, 0x32, 0x39, 0x39, 0x33, 0x2C, 0x22, 0x72, 0x6F, 0x6F, 0x6D, 0x69, 0x64, 0x22, 0x3A, 0x31, 0x30, 0x31, 0x37, 0x2C, 0x22, 0x70, 0x72, 0x6F, 0x74, 0x6F, 0x76, 0x65, 0x72, 0x22, 0x3A, 0x32, 0x2C, 0x22, 0x70, 0x6C, 0x61, 0x74, 0x66, 0x6F, 0x72, 0x6D, 0x22, 0x3A, 0x22, 0x77, 0x65, 0x62, 0x22, 0x2C, 0x22, 0x63, 0x6C, 0x69, 0x65, 0x6E, 0x74, 0x76, 0x65, 0x72, 0x22, 0x3A, 0x22, 0x31, 0x2E, 0x38, 0x2E, 0x32, 0x22, 0x2C, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3A, 0x32, 0x2C, 0x22, 0x6B, 0x65, 0x79, 0x22, 0x3A, 0x22, 0x48, 0x53, 0x39, 0x73, 0x72, 0x41, 0x5F, 0x52, 0x6B, 0x53, 0x64, 0x4B, 0x57, 0x41, 0x54, 0x50, 0x61, 0x73, 0x44, 0x36, 0x47, 0x36, 0x35, 0x59, 0x59, 0x6E, 0x63, 0x71, 0x6D, 0x66, 0x2D, 0x64, 0x76, 0x42, 0x55, 0x6E, 0x78, 0x6E, 0x44, 0x55, 0x64, 0x63, 0x45, 0x38, 0x55, 0x4A, 0x54, 0x6E, 0x70, 0x73, 0x70, 0x6D, 0x6B, 0x66, 0x5F, 0x5A, 0x58, 0x49, 0x44, 0x48, 0x54, 0x6B, 0x63, 0x6C, 0x63, 0x6D, 0x7A, 0x59, 0x65, 0x79, 0x65, 0x68, 0x64, 0x4E, 0x4D, 0x51, 0x5A, 0x42, 0x49, 0x54, 0x32, 0x42, 0x77, 0x59, 0x76, 0x68, 0x5A, 0x63, 0x35, 0x41, 0x38, 0x46, 0x46, 0x68, 0x57, 0x51, 0x55, 0x4E, 0x48, 0x4E, 0x51, 0x33, 0x71, 0x34, 0x77, 0x42, 0x75, 0x62, 0x52, 0x7A, 0x46, 0x74, 0x36, 0x75, 0x38, 0x39, 0x57, 0x79, 0x51, 0x3D, 0x22, 0x7D]
#saoyaosanren
send1 = [0x00, 0x00, 0x00, 0xEA, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x01, 0x7B, 0x22, 0x75, 0x69, 0x64, 0x22, 0x3A, 0x39, 0x38, 0x38, 0x36, 0x32, 0x39, 0x39, 0x33, 0x2C, 0x22, 0x72, 0x6F, 0x6F, 0x6D, 0x69, 0x64, 0x22, 0x3A, 0x35, 0x34, 0x34, 0x31, 0x2C, 0x22, 0x70, 0x72, 0x6F, 0x74, 0x6F, 0x76, 0x65, 0x72, 0x22, 0x3A, 0x32, 0x2C, 0x22, 0x70, 0x6C, 0x61, 0x74, 0x66, 0x6F, 0x72, 0x6D, 0x22, 0x3A, 0x22, 0x77, 0x65, 0x62, 0x22, 0x2C, 0x22, 0x63, 0x6C, 0x69, 0x65, 0x6E, 0x74, 0x76, 0x65, 0x72, 0x22, 0x3A, 0x22, 0x31, 0x2E, 0x38, 0x2E, 0x32, 0x22, 0x2C, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3A, 0x32, 0x2C, 0x22, 0x6B, 0x65, 0x79, 0x22, 0x3A, 0x22, 0x41, 0x4D, 0x33, 0x41, 0x6C, 0x74, 0x77, 0x59, 0x6E, 0x64, 0x76, 0x6A, 0x62, 0x58, 0x33, 0x34, 0x36, 0x4F, 0x77, 0x44, 0x52, 0x54, 0x53, 0x4D, 0x62, 0x58, 0x52, 0x61, 0x48, 0x6D, 0x7A, 0x4B, 0x33, 0x30, 0x35, 0x41, 0x71, 0x63, 0x62, 0x41, 0x34, 0x56, 0x4B, 0x57, 0x69, 0x2D, 0x68, 0x56, 0x61, 0x32, 0x57, 0x76, 0x43, 0x4C, 0x62, 0x59, 0x6A, 0x49, 0x55, 0x6E, 0x6F, 0x65, 0x77, 0x32, 0x34, 0x47, 0x33, 0x74, 0x78, 0x38, 0x53, 0x44, 0x79, 0x58, 0x55, 0x78, 0x51, 0x7A, 0x47, 0x48, 0x4E, 0x34, 0x43, 0x66, 0x79, 0x70, 0x47, 0x6E, 0x48, 0x39, 0x43, 0x39, 0x55, 0x66, 0x69, 0x30, 0x64, 0x61, 0x57, 0x43, 0x67, 0x38, 0x6B, 0x61, 0x4C, 0x6F, 0x4F, 0x35, 0x7A, 0x51, 0x31, 0x6B, 0x53, 0x50, 0x56, 0x54, 0x4C, 0x67, 0x3D, 0x3D, 0x22, 0x7D]
#痒局长
#send1 = [0x00, 0x00, 0x00, 0xEE, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x01, 0x7B, 0x22, 0x75, 0x69, 0x64, 0x22, 0x3A, 0x39, 0x38, 0x38, 0x36, 0x32, 0x39, 0x39, 0x33, 0x2C, 0x22, 0x72, 0x6F, 0x6F, 0x6D, 0x69, 0x64, 0x22, 0x3A, 0x31, 0x32, 0x39, 0x35, 0x35, 0x37, 0x38, 0x35, 0x2C, 0x22, 0x70, 0x72, 0x6F, 0x74, 0x6F, 0x76, 0x65, 0x72, 0x22, 0x3A, 0x32, 0x2C, 0x22, 0x70, 0x6C, 0x61, 0x74, 0x66, 0x6F, 0x72, 0x6D, 0x22, 0x3A, 0x22, 0x77, 0x65, 0x62, 0x22, 0x2C, 0x22, 0x63, 0x6C, 0x69, 0x65, 0x6E, 0x74, 0x76, 0x65, 0x72, 0x22, 0x3A, 0x22, 0x31, 0x2E, 0x38, 0x2E, 0x32, 0x22, 0x2C, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3A, 0x32, 0x2C, 0x22, 0x6B, 0x65, 0x79, 0x22, 0x3A, 0x22, 0x46, 0x2D, 0x65, 0x68, 0x44, 0x44, 0x31, 0x79, 0x4E, 0x38, 0x71, 0x71, 0x77, 0x55, 0x71, 0x7A, 0x65, 0x4A, 0x6D, 0x45, 0x77, 0x70, 0x63, 0x56, 0x66, 0x6D, 0x4E, 0x78, 0x45, 0x53, 0x6C, 0x47, 0x54, 0x6E, 0x53, 0x59, 0x6E, 0x4A, 0x7A, 0x42, 0x50, 0x46, 0x56, 0x58, 0x55, 0x64, 0x7A, 0x56, 0x62, 0x34, 0x75, 0x39, 0x6C, 0x36, 0x7A, 0x36, 0x59, 0x6B, 0x4C, 0x74, 0x73, 0x35, 0x4B, 0x4C, 0x7A, 0x5F, 0x66, 0x49, 0x53, 0x43, 0x6D, 0x39, 0x73, 0x63, 0x6A, 0x31, 0x4F, 0x37, 0x38, 0x6D, 0x51, 0x50, 0x33, 0x65, 0x56, 0x58, 0x61, 0x4E, 0x2D, 0x68, 0x70, 0x6D, 0x67, 0x69, 0x67, 0x77, 0x70, 0x42, 0x7A, 0x51, 0x35, 0x5F, 0x75, 0x76, 0x7A, 0x4A, 0x32, 0x37, 0x50, 0x49, 0x45, 0x2D, 0x38, 0x42, 0x41, 0x63, 0x72, 0x56, 0x6F, 0x3D, 0x22, 0x7D]
#ye11owtail
send2 = [0x00, 0x00, 0x00, 0x1F, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x5B, 0x6F,
         0x62, 0x6A, 0x65, 0x63, 0x74, 0x20, 0x4F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x5D]
def decode_json(msg):
    return json.loads(msg[16:])
def decomp(msg):
    try:
        return zlib.decompress(msg[16:])
    except Exception:
        print('error in decomp : {}'.format(msg[16:]))

def decode_msg(msg,debug=False):
    if debug:
        print(msg)
    if len(msg)==16:
        return []
    if len(msg)==20:
        print('当前观众：{}'.format(int.from_bytes(msg[16:], byteorder='big')))
        return []
    try:
        return [decode_json(msg)]
    except Exception:
        temp = decomp(msg)
#         print(split_jsons(temp))
        return [json.loads(i) for i in split_jsons(temp)]

def split_jsons(test_msg_4):
    activate=1
    stack=0
    start=[]
    end=[]
    escape=0
    i=16
    while i<len(test_msg_4):
#         print('i={},msg[i]={},stack={}'.format(i,bytes([test_msg_4[i]]),stack))
        if test_msg_4[i]==34 and escape%2!=1:
            activate=1-activate
            i+=1
            continue
        if test_msg_4[i]==92:
            escape+=1
        else:
            escape=0
        if activate:
            if test_msg_4[i]==123:
                if stack==0:
                    start.append(i)
                stack+=1
            if test_msg_4[i]==125:
                stack-=1
                if stack==0:
                    end.append(i)
                    i+=16
        i+=1
    result=[]
    for i2 in range(len(start)):
        try:
            result.append(test_msg_4[start[i2]:end[i2]+1])
        except Exception:
            print('error while append bytes to result at split_jsons.')
            print('start & end : {},{}'.format(start,end))
            print('msg : \n{}'.format(test_msg_4))
    return result

def on_message(ws, message):
    try:
        [handler(q,i,True) for i in decode_msg(message)]

    except Exception:
            print(Exception)


def on_error(ws, error):
    print(error)

def on_close(ws):
    print("### closed ###")

def on_open(ws):
    def run(*args):
        ws.send(bytes(send1))
        while True:
            ws.send(bytes(send2))
            time.sleep(30)
    thread.start_new_thread(run, ())

def handler(q,msg,debug=False):
    if msg['cmd'] == 'DANMU_MSG':
        q.put(pd.Series({'msg': msg['info'][1],
                             'uid': msg['info'][2][0],
                             'id':msg['info'][2][1],
                             'time': time.strftime("%m-%d %H:%M:%S", time.localtime(msg['info'][0][4]))}))
        #print(msg['info'][1],msg['info'][2][0],msg['info'][2][1])#测试
        
        def timectrl():
    def job_func1():
        global flag  
        print('timectrl() working!',datetime.datetime.now().strftime('%H:%M:%S'))
        flag = False
        print('flag is off by timectrl now',datetime.datetime.now().strftime('%H:%M:%S'))
    
    scheduler = BackgroundScheduler()

    scheduler.add_job(job_func1, 
                      'interval', 
                      seconds=30, 
                      start_date='2019-09-08 12:05:30',
                      end_date='2019-09-19 14:55:00')
    
    # scheduler .add_job(job_func1, 'interval', seconds=5, start_date='2019-08-09 02:23:00' , end_date='2019-08-09 02:23:00')
    scheduler.start()


def tem_data():
    global flag
    flag = True
    Tem = pd.DataFrame(columns=['msg', 'uid', 'time'])

    '''
      msg  uid time id
    0  1    2   3   4
    1  2    3   4   5
   '''
    print('Tem is already to output at',datetime.datetime.now().strftime('%H:%M:%S'))
    while  flag:
        Tem = Tem.append(q.get(), ignore_index=True)#ignore_index=True 实现按照行排列进行拼接
    print('Tem is outputed at',datetime.datetime.now().strftime('%H:%M:%S'))
    q3.put(Tem)


def handle_data(): 
    Tem = q3.get()  # 从q3中取出tem并去除重复内容，存入数据库
    Tem_drop_dup = Tem['uid'].drop_duplicates() #去重得到无重复内容的series
    Tem_2 = Tem.iloc[Tem_drop_dup.index] #以series的index得到新的无重复uid内容的dataframe
    Tem=Tem_2['msg'].value_counts()     #将新的dataframe按msg中的数量多少得到series（投票内容msg为index和重复次数为value）
    Tem=Tem.head(3)
    tar=list(Tem.index)                 #拿出数量最多的三个投票结果和投票数量 index为投票内容，values为投票数量
    tar2=list(Tem.values)              
    d={}                               #用字典保存Tem前三值
    for i in range(len(tar)):
        d[str(i)]=[tar[i],str(tar2[i])]          #mongodb列名称只接受string，所以把字典的key进行str  
        #d[str(i)+str(i)]=tar2[i]
    print(d)
    if d!={}:       #d为空集时不动作
        bd['danmucaiji2'].insert(d)
        q2.put(True) #顺序读取，当q2得到内容后，交易指令控制模块才开始
        
def fuc():
    while True:
        tem_data()


def fuc2():
    while True:
        handle_data()
        
q = Queue()
q2 = Queue()
q3 = Queue()  
websocket.enableTrace(True)
conn = pymongo.MongoClient('localhost', 27017)
bd = conn['projectyellow_1']
col = bd['danmucaiji2']
ws = websocket.WebSocketApp(websocket_url,
                            on_message=on_message,
                            on_error=on_error,
                            on_close=on_close)
ws.on_open = on_open
t1 = threading.Thread(target=ws.run_forever)
t2 = threading.Thread(target=fuc)
t3 = threading.Thread(target=fuc2)
timectrl()
t1.start()
t2.start()
t3.start()
